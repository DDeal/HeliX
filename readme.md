# HeliX Chat

## Introduction / Overview

**What is HeliX?**

HeliX is a browser-based, end-to-end encrypted (E2EE), ephemeral chat system. It allows two users to establish a secure, temporary chat session directly between their browsers, with a simple Python server acting only as a relay for connection setup and encrypted messages.

**Core Features:**

*   **End-to-End Encryption:** Messages are encrypted in your browser and can only be decrypted by the intended recipient. The server cannot read your messages. Uses Web Crypto API (RSA-OAEP for key exchange, AES-GCM for messages).
*   **Ephemeral:** Chat messages exist only in the browser's memory during an active session. They are lost when the session ends, the browser tab is closed, or the server restarts. No message history is stored on the server or persistently on the client.
*   **Serverless Message Storage:** The Python server only relays data; it does not store message content.
*   **Simple Identifier System:** Users register with a temporary, unique ID for the duration of their connection to the server. IDs must be shared out-of-band.
*   **Self-Hosted:** You run the server components yourself, giving you control over the relay infrastructure.
*   **Basic & Focused:** Designed for simple, secure, temporary peer-to-peer conversations.

**Target Use Case:**

HeliX is ideal for situations where you need a quick, secure way to chat with someone without relying on third-party services or leaving a persistent message history. Examples include sharing sensitive information temporarily, quick technical support sessions, or private coordination.

**Disclaimer:**

HeliX is currently experimental software. While it implements strong E2EE principles, it has not undergone a formal security audit. Use it at your own risk. The security of your communication depends heavily on the correct setup, the security of the devices used, the secure exchange of user identifiers, and trusting the `mkcert` local Certificate Authority if you install it.

---

## How HeliX Works & Security

**High-Level Architecture:**

1.  **Client:** Runs entirely in the user's web browser using HTML, CSS, and JavaScript. It handles:
    *   User Interface (UI) interactions.
    *   Generating cryptographic keys (RSA and AES) via the browser's Web Crypto API.
    *   Encrypting and decrypting messages.
    *   Communicating with the WSS server via Secure WebSockets.
2.  **HTTPS Server:** A simple Python server (integrated into `helix_manager.py`) serves the static client files (HTML, CSS, JS) to the browser over HTTPS. This is **required** for the Web Crypto API to function securely.
3.  **WSS Server:** A Python server using the `websockets` library. It acts as a signaling and relay server:
    *   Manages user registrations (mapping temporary IDs to connections).
    *   Relays handshake messages (key exchange, challenges) between clients.
    *   Relays the **encrypted** chat messages between connected peers.
    *   **Crucially, the WSS server never sees the plaintext message content.**

**End-to-End Encryption (E2EE):**

HeliX ensures that only the sender and the intended recipient can read messages. This is achieved through:

1.  **Session Handshake:** When User A wants to chat with User B:
    *   They exchange temporary RSA public keys.
    *   They perform a challenge-response verification to ensure they are talking to the holder of the corresponding private key and not an imposter.
2.  **Message Encryption:** For each message sent during an active session:
    *   A new, random AES-GCM symmetric key is generated by the sender.
    *   The message text is encrypted using this AES key and a unique Initialization Vector (IV). AES-GCM provides both confidentiality and authenticity.
    *   The AES key itself is encrypted using the recipient's RSA public key (obtained during the handshake).
    *   The encrypted AES key, the IV, and the AES-encrypted message data are sent to the WSS server.
3.  **Server Relay:** The WSS server receives this bundle and relays it to the recipient *without* being able to decrypt any part of it (as it doesn't have the recipient's private RSA key).
4.  **Message Decryption:** The recipient's client:
    *   Decrypts the AES key using their own private RSA key.
    *   Uses the decrypted AES key and the received IV to decrypt the actual message data.

**Ephemeral Nature:**

*   Messages are not stored on the server disk or database.
*   Messages are not stored persistently in the browser (e.g., in `localStorage`). They only reside in active JavaScript memory.
*   Closing the browser tab, ending the session via the "Disconnect" button, or stopping the WSS server will cause the messages and session keys to be lost.

**HTTPS Importance:**

Modern web browsers require a secure context (HTTPS or `localhost`) to grant access to the Web Crypto API, which HeliX relies on for all its cryptographic operations. The integrated HTTPS server provides this secure context. We use `mkcert` to easily generate locally-trusted TLS certificates for development and local network use.

**Identifier System:**

HeliX uses simple, temporary identifiers chosen by the user upon connecting.

*   These IDs are only valid while the user is connected to the WSS server.
*   IDs must be unique on the server at any given time.
*   **Crucially, you must share your ID with the person you want to chat with through a separate, secure channel** (e.g., phone call, Signal message, in person). HeliX does not provide a discovery mechanism.

**Security Considerations & Assumptions:**

*   **Server Trust:** You must trust the machine running the WSS and HTTPS servers. While the server cannot read messages, a compromised server could potentially interfere with connections or attempt more advanced attacks (though TLS and E2EE mitigate many risks).
*   **Client Trust:** Communication is only as secure as the endpoint devices. If a user's computer or browser is compromised, the E2EE can be bypassed locally.
*   **`mkcert` CA Trust:** For browsers to accept the HTTPS connection without warnings, the `mkcert` local Certificate Authority (CA) must be installed and trusted by your operating system/browser. The manager script offers to run `mkcert -install`, but this requires user confirmation and potentially administrator privileges. Accessing the client via an IP address or hostname not listed in the certificate (`localhost`, `127.0.0.1`) *will* result in browser warnings, even if the CA is installed.
*   **Identifier Exchange:** The security of initiating a conversation depends on how securely you exchange identifiers with your peer.
*   **No Perfect Forward Secrecy (PFS):** The current implementation uses RSA for key exchange. While secure, if an attacker were to record all traffic *and* later compromise a user's long-term private RSA key (which HeliX doesn't currently use, as keys are session-based), they could potentially decrypt past messages. Protocols like Signal use algorithms (e.g., variations of Diffie-Hellman) to provide PFS, which is a potential future enhancement for HeliX.
*   **No Metadata Protection:** The server knows *who* is talking to *whom* (based on IDs and relayed messages) and *when*, just not *what* they are saying.

---

## Prerequisites

Before setting up HeliX, ensure you have the following:

*   **Operating System:** Windows, macOS, or Linux (tested primarily on Linux and Windows, but it should work on others).
*   **Python:** Python 3.7 or newer recommended. Download from [python.org](https://www.python.org/downloads/). Ensure Python and Pip are added to your system's PATH during installation.
*   **Pip:** Python's package installer, usually included with Python 3.4+.
*   **`mkcert` Utility:** A tool for creating locally-trusted development certificates.
    *   Download from the [mkcert GitHub Releases page](https://github.com/FiloSottile/mkcert/releases).
    *   **Crucially:** Follow the specific setup instructions in the "Installation & Setup" section below for your OS *before* running the HeliX manager's certificate option.

---

## Installation & Setup

1.  **Get the Code:**
    *   **Option A (Git):** Clone the repository:
        ```bash
        git clone https://github.com/DDeal/HeliX.git
        cd helix
        ```
    *   **Option B (Download):** Download the project ZIP file and extract it. Navigate into the extracted `helix` directory in your terminal.

2.  **Directory Structure:** Ensure your directory looks like this:
    ```
    helix/
    ├── helix_manager.py
    ├── client/
    │   ├── css/
    │   ├── js/
    │   └── index.html
    ├── server/
    │   ├── config.py
    │   ├── main.py
    │   └── server.py
    ├── certs/          # Directory for certificates (and mkcert.exe on Windows)
    └── logs/           # Directory for logs (created automatically)
    ```

3.  **Run the Manager Script (Initial Run):**
    *   Open your terminal or command prompt, navigate to the `helix` directory.
    *   Run the manager script:
        ```bash
        python helix_manager.py
        ```

4.  **Dependency Check:**
    *   The script will automatically check if the required `websockets` Python library is installed.
    *   If not found, it will prompt you to install it using `pip`. Enter `y` to allow installation.

5.  **Certificate Generation & Management (Using Menu Option 5):**
    *   The manager script requires TLS certificates (`cert.pem`, `key.pem`) in the `certs/` directory to run the HTTPS server. Use **Menu Option 5** ("Manage TLS Certificates") to handle this *before* starting the servers.
    *   **`mkcert` Setup (Do this *before* selecting Menu Option 5):**
        *   **Windows:** Download `mkcert-vX.Y.Z-windows-amd64.exe` from the [mkcert releases page](https://github.com/FiloSottile/mkcert/releases). Rename it to `mkcert.exe` and place it **inside the `helix/certs/` directory**.
        *   **Linux/macOS:** Install `mkcert` using your system's package manager so it's available in your PATH. Examples:
            *   macOS (using Homebrew): `brew install mkcert`
            *   Linux (Debian/Ubuntu): `sudo apt install mkcert`
            *   Linux (Other): Consult your distribution's package manager or the mkcert documentation.
    *   **Running Menu Option 5:**
        *   Select option 5 from the manager menu.
        *   The script will find `mkcert` (based on the setup above).
        *   It will display the `mkcert` version found.
        *   **CA Installation:** It will ask if you want to run `mkcert -install`. This installs the `mkcert`-generated local Certificate Authority (CA) into your system/browser trust stores.
            *   **Recommended:** Enter `y` for this. It prevents most browser security warnings when accessing `https://localhost` or `https://127.0.0.1`.
            *   **Requires Admin/Sudo:** This step usually requires administrator or `sudo` privileges. You may see a password prompt from your OS.
            *   If it fails, you might need to run `mkcert -install` manually with the necessary privileges.
        *   **Certificate Overwrite/Backup:** If `cert.pem` and `key.pem` already exist in `certs/`, it will ask if you want to overwrite them. If you choose yes, it will then ask if you want to back up the old files to `cert_old.pem` and `key_old.pem`.
        *   **Generation:** If needed (no existing certs or user chose to overwrite), it will run `mkcert` to generate `cert.pem` and `key.pem` specifically for `localhost` and `127.0.0.1`.

6.  **Network Configuration for External Access (Optional):**
    *   By default, the servers listen on `0.0.0.0`, meaning they accept connections from `localhost` and other devices on your local network (LAN).
    *   To allow connections from *outside* your local network (e.g., over the internet), you typically need to configure:
        *   **Firewall:** Ensure your OS firewall allows incoming connections on the ports used by HeliX (default: TCP `5678` for WSS, TCP `8888` for HTTPS, or the ports you configured in the menu).
        *   **Router Port Forwarding:** Configure your internet router to forward incoming traffic on the external ports (e.g., 5678, 8888) to the internal IP address of the computer running HeliX on the same ports.
    *   **Disclaimer:** Configuring firewalls and routers varies greatly depending on your specific hardware, software, and network setup. This is beyond the scope of the HeliX documentation. Please consult your OS and router documentation.
    *   **Certificate Consideration for External Access:**
        *   The certificates generated by the manager script using `mkcert` are only valid for `localhost` and `127.0.0.1`.
        *   If you access HeliX using your computer's LAN IP, external IP, or a domain name, your browser **will show a security warning** because the name in the URL doesn't match the names in the certificate.
        *   For personal or trusted LAN use, you can usually choose to bypass this warning (look for "Advanced" -> "Proceed to..." options in your browser).
        *   For a seamless experience without warnings when accessed externally via a domain name, the recommended approach involves using a reverse proxy (like Nginx, Caddy, Traefik) and obtaining publicly trusted certificates (e.g., from Let's Encrypt). Setting up a reverse proxy is an advanced topic not covered here.

---

## Running HeliX

1.  **Start the Servers:**
    *   Run the manager script: `python helix_manager.py`
    *   Use the menu to configure ports/hosts if desired.
    *   Ensure certificates exist (use Menu Option 5 if needed).
    *   Select **Option 6** ("Save WSS Config and Start Servers") or **Option 7** ("Start Servers...") from the menu.

2.  **Expected Output:**
    *   You will see messages indicating the HTTPS server thread and WSS server subprocess are starting.
    *   Real-time logs from the WSS server (client connections, registrations, relays) will be printed to the console, prefixed with `[WSS]`.
    *   The HTTPS server will log its activity (requests served) to the `logs/https_server.log` file.

3.  **Access the Client:**
    *   Open your web browser (Firefox, Chrome, Edge recommended).
    *   Navigate to the HTTPS URL corresponding to the HTTPS Host and Port configured in the manager. Defaults:
        *   `https://localhost:8888`
        *   `https://127.0.0.1:8888`
    *   If accessing from another device on your LAN, use `https://<helix-server-lan-ip>:8888` (replace with the actual LAN IP).
    *   **Browser Warnings:**
        *   If you did not successfully run `mkcert -install` (or your browser doesn't use the OS trust store), you *will* see a security warning page (e.g., "Your connection is not private", "Warning: Potential Security Risk Ahead").
        *   If you are accessing via an IP address or a hostname other than `localhost` or `127.0.0.1`, you *will* see this warning, even if the CA is installed.
        *   For local/trusted use, you can typically bypass this warning: click "Advanced", then look for an option like "Proceed to localhost (unsafe)" or "Accept the Risk and Continue". The exact wording varies by browser.

4.  **Stop the Servers:**
    *   Go back to the terminal where `helix_manager.py` is running.
    *   Press `Ctrl+C`.
    *   The manager script will intercept this signal and attempt to gracefully shut down both the WSS process and the HTTPS server thread. You will see shutdown messages.

---

## Usage Guide

1.  **Access Client:** Open the correct `https://...` URL in your browser (see "Running HeliX").
2.  **Registration:** You'll see the registration screen.
    *   Choose a unique temporary identifier (e.g., `Alice_Work`, `Bob_Secure`).
    *   Click "Register". The status bar at the bottom should update.
3.  **Main Interface:** After registration, you'll see the main layout:
    *   **Sidebar (Left):** Shows "Your ID:", allows starting new chats, lists active/pending sessions.
    *   **Main Content (Right):** Initially shows the Welcome message. Will display chat windows, request prompts, or info messages.
    *   **Status Bar (Bottom):** Shows current connection status and activity.
4.  **Share Your ID:** Securely communicate your registered ID (shown in the sidebar) to the person you want to chat with using an out-of-band method (phone, secure messenger, etc.). They will need this ID to initiate a chat with you (or vice-versa).
5.  **Starting a Chat:**
    *   Enter your peer's registered HeliX ID into the "Start chat with ID" box in the sidebar.
    *   Click "Start Chat".
    *   The main content area will show a "Waiting for `<PeerID>` to respond..." message. You can click "Cancel Request" here.
6.  **Receiving a Chat Request:**
    *   If someone starts a chat with your ID:
        *   If you are viewing the Welcome screen, the main content area will change to show "Incoming chat request from `<PeerID>`. Accept or Deny?". Click "Accept" or "Deny".
        *   If you are already in another chat, the new session will appear in the sidebar list with a notification dot. Click on that session in the list to bring up the Accept/Deny prompt.
7.  **Active Chatting:**
    *   Once a session is established (request accepted, handshake complete), the main content area shows the chat view.
    *   The header shows "Chatting with: `<PeerID>`".
8.  **Ending a Session:**
    *   Click the "Disconnect" button in the chat header to end the current session. The peer will be notified, and the session will be removed locally.
    *   If the peer disconnects, you will see a "Session ended by `<PeerID>`" message, and the session will close.
9.  **Switching Between Sessions:** If you have multiple sessions (e.g., one active, one incoming request), click the desired peer ID in the sidebar list to switch the main content view.
10. **Understanding Info Panes:** If a request is denied, times out, or another error occurs related to a session, the main content area may show an info pane with details. Use the "Close" or "Retry" (if available) buttons.

---

## Troubleshooting

*   **`websockets` library not found:** Run `python helix_manager.py`. If prompted, allow it to install the library (`y`). If that fails, install manually: `pip install websockets`.
*   **`mkcert` not found:** Ensure `mkcert` is installed correctly for your OS and either in the PATH (Linux/macOS) or `certs/mkcert.exe` exists (Windows). See the "Certificate Generation & Management" section.
*   **Browser Certificate Warnings (NET::ERR_CERT_AUTHORITY_INVALID, SEC_ERROR_UNKNOWN_ISSUER, etc.):**
    *   **Cause:** Your browser doesn't trust the `mkcert` local CA, or you are accessing via an IP/hostname not listed in the certificate.
    *   **Solution 1 (Recommended):** Use the manager script's Menu Option 5 and agree to run `mkcert -install` (may require admin/sudo). Restart your browser after installation. This works best for `localhost` and `127.0.0.1`.
    *   **Solution 2 (Bypass):** For local/trusted use, especially when accessing via IP, you can usually bypass the warning. Click "Advanced" -> "Proceed to..." or "Accept Risk...".
    *   **Solution 3 (External/Domain):** Use a reverse proxy with publicly trusted certificates (advanced setup).
*   **Cannot Connect to Server (Client shows "Connecting..." or "Failed"):**
    *   Verify both servers (WSS, HTTPS) were started successfully via `helix_manager.py`. Check the console output for errors.
    *   Check if the WSS Port (default 5678) and HTTPS Port (default 8888) are correct in the client's `js/config.js` (for WSS) and the URL you are using in the browser (for HTTPS).
    *   Check OS firewall rules on the server machine. Are incoming connections allowed on the required ports?
    *   If connecting from another device, ensure you are using the correct LAN IP address of the server machine.
*   **Cannot Connect from Outside LAN:**
    *   Verify firewall rules *and* router port forwarding are correctly configured for both the WSS and HTTPS ports. See the "Network Configuration for External Access" section.
*   **Registration Failed ("Identifier already taken"):** Choose a different temporary ID.
*   **Chat Request Failed ("User not found or disconnected"):** The peer you tried to contact is not currently registered with the server using that ID, or they disconnected. Verify the ID and ensure they are online.
*   **Port Conflict ("Address already in use"):** Another application is using port 5678 or 8888 (or your configured ports). Stop the other application or configure HeliX to use different ports via the manager menu.

---

## License

MIT License

Copyright (c) 2025 DigitalMafia / Project Name

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
