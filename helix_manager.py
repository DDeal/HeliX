#!/usr/bin/env python3
# helix_manager.py - Main control script for HeliX Chat
#
# This script provides a command-line interface to manage the HeliX chat application:
# - Checks for required Python packages listed in server/requirements.txt and offers installation.
# - Provides a menu option to manage TLS certificates using 'mkcert':
#   - Checks for 'mkcert' utility (in PATH or ./certs/mkcert.exe on Windows).
#   - Offers to install the mkcert CA for browser trust.
#   - Generates/overwrites local TLS certificates (cert.pem, key.pem) for localhost/127.0.0.1.
#   - Offers to back up existing certificates before overwriting.
# - Allows viewing and modifying configuration settings:
#   - WSS Host/Port (Saved persistently to server/config.py)
#   - HTTPS Host/Port (Used for the manager's current session only)
#   - Server Debug Mode (Saved persistently to server/config.py)
#   - Client Debug Mode (Saved persistently to client/js/config.js)
# - Starts both the WebSocket Secure (WSS) server (as a subprocess) and
#   an integrated HTTPS server (in a separate thread) to serve client files.
#   (Requires certificates to exist before starting).
# - Displays real-time logs from the WSS server to the console.
# - Logs HTTPS server activity to a file (logs/https_server.log).
# - Handles graceful shutdown of both servers on Ctrl+C.

import subprocess         # For running external processes (WSS server, pip, mkcert).
import sys                # For accessing Python interpreter path and exiting.
import os                 # For path manipulation (finding files, creating dirs, renaming).
import re                 # For regular expressions used in config file parsing and dependency parsing.
import importlib.util     # For checking if a library is installed without importing it directly.
import threading          # For running the HTTPS server and WSS logger concurrently.
import time               # For pausing execution (e.g., in wait loops, server startup delay).
import ssl                # For setting up the SSL context for the HTTPS server.
import http.server        # For the basic HTTPS file server implementation.
import logging            # For logging HTTPS server activity to a file.
import platform           # For detecting the operating system (Windows, Linux, Darwin).
import shutil             # For finding executables in PATH (shutil.which).
from socketserver import ThreadingMixIn # To make the HTTPS server handle requests in separate threads.
from functools import partial # Used for creating the HTTPS request handler with a specific directory.

# --- Constants ---
# Define file paths relative to the location of this script for portability.
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__)) # Absolute path to the directory containing this script.
# Path to the WSS server configuration file.
CONFIG_FILE_PATH = os.path.join(SCRIPT_DIR, 'server', 'config.py')
# Path to the client configuration file.
CLIENT_CONFIG_FILE_PATH = os.path.join(SCRIPT_DIR, 'client', 'js', 'config.js')
# Path to the server requirements file.
REQUIREMENTS_FILE_PATH = os.path.join(SCRIPT_DIR, 'server', 'requirements.txt')
# Path to the directory containing client files served by the HTTPS server.
HTTPS_CLIENT_DIR = os.path.join(SCRIPT_DIR, 'client')
# Path to the directory where SSL certificates are stored.
CERT_DIR = os.path.join(SCRIPT_DIR, 'certs')
# Expected filename for the SSL certificate file (public key).
CERT_FILE = os.path.join(CERT_DIR, 'cert.pem')
# Expected filename for the SSL private key file.
KEY_FILE = os.path.join(CERT_DIR, 'key.pem')
# Filename used for backing up the existing certificate file.
CERT_OLD_FILE = os.path.join(CERT_DIR, 'cert_old.pem')
# Filename used for backing up the existing private key file.
KEY_OLD_FILE = os.path.join(CERT_DIR, 'key_old.pem')
# Directory to store log files generated by the manager.
LOG_DIR = os.path.join(SCRIPT_DIR, 'logs')
# Log file specifically for the integrated HTTPS server.
HTTPS_LOG_FILE = os.path.join(LOG_DIR, 'https_server.log')

# --- Global Variables for Server Management ---
# These variables hold references to the running processes and threads
# to allow for proper management (monitoring, shutdown).
wss_process = None      # Holds the subprocess.Popen object for the WSS server process.
https_server = None     # Holds the http.server.HTTPServer instance for the HTTPS server.
https_thread = None     # Holds the threading.Thread object running the HTTPS server.
wss_log_thread = None   # Holds the threading.Thread object reading WSS server logs.
stop_event = threading.Event() # A synchronization primitive used to signal threads (like the WSS logger) to stop gracefully.

# --- Logging Setup for HTTPS Server ---
# Configure a dedicated logger for the HTTPS server to write activity to a file,
# separate from the WSS server logs shown on the console.
https_logger = logging.getLogger('HTTPServer') # Get a specific logger instance named 'HTTPServer'.
https_logger.setLevel(logging.INFO) # Set the minimum logging level to INFO.
# Ensure the log directory exists before trying to write to it.
os.makedirs(LOG_DIR, exist_ok=True)
# Create a file handler to write logs to the specified file in append mode ('a').
https_file_handler = logging.FileHandler(HTTPS_LOG_FILE, mode='a', encoding='utf-8')
# Define the format for log messages written to the file (timestamp - message).
https_file_handler.setFormatter(logging.Formatter('%(asctime)s - %(message)s'))
# Add the configured file handler to our dedicated logger.
https_logger.addHandler(https_file_handler)
# Prevent messages logged by this logger from propagating up to the root logger
# (which might log to the console by default).
https_logger.propagate = False

# --- Dependency Management ---
def parse_package_name(requirement_line):
    """
    Parses a requirement line from requirements.txt to extract the base package name.
    Handles common version specifiers (e.g., '==', '>=', '<=').

    Args:
        requirement_line (str): A single line from a requirements.txt file.

    Returns:
        str or None: The extracted package name (e.g., 'websockets'),
                     or None if the line is empty, a comment, or invalid.
    """
    line = requirement_line.strip()
    # Ignore empty lines and lines starting with '#'.
    if not line or line.startswith('#'):
        return None
    # Use regex to match the beginning of the line containing valid package name characters.
    # This captures the name before any version specifiers like '==', '>=', etc.
    match = re.match(r"^[a-zA-Z0-9._-]+", line)
    if match:
        return match.group(0) # Return the matched package name.
    return None # Return None if no valid package name start is found.

def check_dependencies():
    """
    Checks if Python packages listed in server/requirements.txt are installed.
    If any are missing, prompts the user to install them using pip.
    Exits the manager script if installation is declined or fails.
    """
    print(f"Checking dependencies listed in {REQUIREMENTS_FILE_PATH}...")
    missing_packages = []
    try:
        # Read the requirements file line by line.
        with open(REQUIREMENTS_FILE_PATH, 'r', encoding='utf-8') as f:
            requirements = f.readlines()

        # Check each requirement line.
        for line in requirements:
            package_name = parse_package_name(line)
            if package_name:
                # Use importlib.util.find_spec for a lightweight check without actually importing the package.
                # find_spec returns None if the package cannot be found.
                spec = importlib.util.find_spec(package_name)
                if spec is None:
                    print(f"  - Package '{package_name}' not found.")
                    missing_packages.append(package_name)

        # If any packages were found to be missing, prompt the user for installation.
        if missing_packages:
            print("\nSome required packages are missing.")
            package_list = ", ".join(missing_packages)
            confirm = input(f"Attempt to install missing packages ({package_list}) using pip? (y/n): ").lower().strip()
            if confirm == 'y':
                print(f"Installing packages from {REQUIREMENTS_FILE_PATH}...")
                try:
                    # Run 'pip install -r requirements.txt' using the current Python interpreter.
                    # check=True raises CalledProcessError if pip fails.
                    # capture_output=True hides pip's output unless there's an error.
                    # text=True decodes stdout/stderr as text.
                    subprocess.run(
                        [sys.executable, "-m", "pip", "install", "-r", REQUIREMENTS_FILE_PATH],
                        check=True,
                        capture_output=True,
                        text=True
                    )
                    print("Packages installed successfully.")
                except subprocess.CalledProcessError as e:
                    # Handle errors during the pip installation process.
                    print(f"Error installing packages: {e}")
                    print("--- PIP Error Output ---")
                    print(e.stderr) # Print the captured standard error from pip.
                    print("----------------------")
                    print(f"Please install packages manually (e.g., 'pip install -r {REQUIREMENTS_FILE_PATH}') and restart.")
                    sys.exit(1) # Exit the manager script.
                except FileNotFoundError:
                    # Handle the case where 'pip' itself isn't found.
                    print("Error: 'pip' command not found. Is Python installed correctly and in your PATH?")
                    sys.exit(1) # Exit the manager script.
            else:
                # User chose not to install automatically.
                print("Installation declined. Please install required packages manually and restart.")
                sys.exit(1) # Exit the manager script.
        else:
            # All required packages were found.
            print("All required packages found.")

    except FileNotFoundError:
        # Handle the case where the requirements.txt file itself is missing.
        print(f"Error: {REQUIREMENTS_FILE_PATH} not found. Cannot check dependencies.")
        print("Please ensure the requirements file exists or install dependencies manually.")
        sys.exit(1)
    except Exception as e:
        # Catch any other unexpected errors during the dependency check.
        print(f"An unexpected error occurred during dependency check: {e}")
        sys.exit(1)


# --- Certificate Generation ---
def generate_certificates():
    """
    Manages TLS certificate generation using the 'mkcert' utility.
    Finds the mkcert executable, displays its version, offers to install the local CA,
    handles overwriting or backing up existing certificates, and generates new ones
    for 'localhost' and '127.0.0.1'.

    Returns:
        bool: True if certificates exist or were successfully generated/handled, False otherwise.
    """
    print("\n--- Certificate Management ---")
    os.makedirs(CERT_DIR, exist_ok=True) # Ensure the 'certs' directory exists.

    # 1. Find the mkcert executable.
    mkcert_path = None
    system = platform.system() # Detect the operating system.
    print(f"Detected OS: {system}")
    if system == "Windows":
        # On Windows, first check PATH using shutil.which.
        mkcert_path = shutil.which("mkcert")
        if not mkcert_path:
            # If not in PATH, check for 'mkcert.exe' inside the 'certs' directory.
            expected_path = os.path.join(CERT_DIR, "mkcert.exe")
            if os.path.exists(expected_path):
                mkcert_path = expected_path
            else:
                 # If not found in either location, report error.
                 print(f"Error: 'mkcert.exe' not found in PATH or '{CERT_DIR}'. Install or place it correctly.")
                 return False
        print(f"Found mkcert at: {mkcert_path}")
    elif system in ["Linux", "Darwin"]: # macOS is 'Darwin'
        # On Linux/macOS, check PATH using shutil.which.
        mkcert_path = shutil.which("mkcert")
        if mkcert_path is None:
            # If not found in PATH, report error.
            print("Error: 'mkcert' command not found in your system PATH. Please install it.")
            return False
        print(f"Found mkcert in PATH: {mkcert_path}")
    else:
        # Handle unsupported operating systems.
        print(f"Unsupported OS for mkcert handling: {system}")
        return False

    # 2. Display mkcert version.
    try:
        print("Checking mkcert version...")
        # Run 'mkcert -version' command.
        result = subprocess.run([mkcert_path, "-version"], capture_output=True, text=True, check=True, timeout=10)
        print(f"mkcert version info:\n{result.stdout.strip()}")
    except Exception as e:
        # Log warning if version check fails, but continue.
        print(f"Warning: Could not get mkcert version: {e}")

    # 3. Offer to install the mkcert local Certificate Authority (CA).
    install_ca = input("Attempt to install the mkcert local CA (requires admin/sudo)? (y/n): ").lower().strip()
    if install_ca == 'y':
        print("Running 'mkcert -install'. You might be prompted for your password.")
        try:
            # Run 'mkcert -install' command.
            subprocess.run([mkcert_path, "-install"], check=True, timeout=30)
            print("mkcert CA installation command executed.")
        except Exception as e:
            # Log warning if CA installation fails, but continue.
            print(f"Warning: 'mkcert -install' command failed: {e}")

    # 4. Check for existing certificate files and handle overwrite/backup logic.
    certs_exist = os.path.exists(CERT_FILE) and os.path.exists(KEY_FILE)
    generate_new = True # Assume we need to generate new certs by default.
    if certs_exist:
        print(f"\nExisting certificate files found:\n  {CERT_FILE}\n  {KEY_FILE}")
        overwrite = input("Overwrite existing certificates? (y/n): ").lower().strip()
        if overwrite == 'y':
            backup = input("Backup existing files to cert_old.pem/key_old.pem? (y/n): ").lower().strip()
            if backup == 'y':
                try:
                    print("Backing up existing certificates...")
                    # Use os.replace for atomic rename/move operation.
                    if os.path.exists(CERT_FILE): os.replace(CERT_FILE, CERT_OLD_FILE)
                    if os.path.exists(KEY_FILE): os.replace(KEY_FILE, KEY_OLD_FILE)
                    print(f"Backup complete: {CERT_OLD_FILE}, {KEY_OLD_FILE}")
                except OSError as e:
                    # Log warning if backup fails, but continue.
                    print(f"Warning: Failed to back up existing certificates: {e}")
            else:
                print("Skipping backup.")
        else:
            # User chose not to overwrite.
            print("Using existing certificates.")
            generate_new = False # Do not generate new certs.
    else:
        # Certificates are missing or incomplete.
        print("\nCertificate files missing or incomplete. Will attempt to generate new ones.")

    # 5. Generate new certificates if needed.
    if generate_new:
        print("Generating new certificates for 'localhost' and '127.0.0.1'...")
        try:
            # Construct the mkcert command arguments.
            mkcert_command = [mkcert_path, "-cert-file", CERT_FILE, "-key-file", KEY_FILE, "localhost", "127.0.0.1"]
            # Run the mkcert command.
            result = subprocess.run(mkcert_command, check=True, capture_output=True, text=True, timeout=30)
            print("mkcert generation command executed.")
            # Print output/errors from mkcert for debugging.
            if result.stdout: print(f"mkcert output:\n{result.stdout.strip()}")
            if result.stderr: print(f"mkcert error output:\n{result.stderr.strip()}")
            # Verify that the expected output files were actually created.
            if not (os.path.exists(CERT_FILE) and os.path.exists(KEY_FILE)):
                print("Error: mkcert command seemed to succeed but output files are missing!")
                return False
            print("New certificate and key files generated successfully.")
        except Exception as e:
            # Handle errors during the mkcert generation process.
            print(f"Error during certificate generation: {e}")
            # Print stderr if available from the exception object.
            if hasattr(e, 'stderr') and e.stderr: print(f"--- mkcert Error Output ---\n{e.stderr}\n-------------------------")
            return False

    # 6. Final check to ensure certificate files exist before returning.
    if os.path.exists(CERT_FILE) and os.path.exists(KEY_FILE):
        print("Certificate check passed.")
        return True
    else:
        print("Error: Certificate files not found after completion.")
        return False

# --- Configuration Management ---
def read_config():
    """
    Reads configuration settings from server/config.py and client/js/config.js.
    Uses regular expressions to find specific settings (HOST, PORT, DEBUG).
    Sets default values internally if files or settings are not found or parsing fails.

    Returns:
        dict: A dictionary containing the configuration settings:
              {'wss_host', 'wss_port', 'https_host', 'https_port',
               'server_debug', 'client_debug'}.
    """
    # Initialize settings dictionary with default values.
    settings = {
        'wss_host': '0.0.0.0',
        'wss_port': 5678,
        'https_host': '0.0.0.0', # Default HTTPS host (not saved persistently, used for manager session)
        'https_port': 8888,     # Default HTTPS port (not saved persistently, used for manager session)
        'server_debug': False,  # Default server debug mode (read from server/config.py)
        'client_debug': False   # Default client debug mode (read from client/js/config.js)
    }
    server_config_path = CONFIG_FILE_PATH
    client_config_path = CLIENT_CONFIG_FILE_PATH

    # --- Read Server Config (server/config.py) ---
    try:
        # Read the entire content of the server config file.
        with open(server_config_path, 'r', encoding='utf-8') as f:
            content = f.read()

            # Use regex to find the WSS HOST setting (e.g., HOST = '0.0.0.0').
            # ^ matches start of line, \s* allows whitespace, ['\"] matches single or double quotes.
            # ([^'\"]+) captures the value inside the quotes. re.MULTILINE allows ^ to match start of each line.
            wss_host_match = re.search(r"^HOST\s*=\s*['\"]([^'\"]+)['\"]", content, re.MULTILINE)
            if wss_host_match:
                settings['wss_host'] = wss_host_match.group(1)
            else:
                print(f"Warning: Could not find WSS HOST setting in {server_config_path}, using default '{settings['wss_host']}'.")

            # Use regex to find the WSS PORT setting (e.g., PORT = 5678).
            # (\d+) captures one or more digits.
            wss_port_match = re.search(r"^PORT\s*=\s*(\d+)", content, re.MULTILINE)
            if wss_port_match:
                settings['wss_port'] = int(wss_port_match.group(1)) # Convert captured string to integer.
            else:
                print(f"Warning: Could not find WSS PORT setting in {server_config_path}, using default {settings['wss_port']}.")

            # Use regex to find the Server DEBUG setting (e.g., DEBUG = True or DEBUG = False).
            # (True|False) captures either 'True' or 'False'.
            server_debug_match = re.search(r"^DEBUG\s*=\s*(True|False)", content, re.MULTILINE)
            if server_debug_match:
                # Convert the captured Python boolean string ('True'/'False') to an actual boolean value.
                settings['server_debug'] = server_debug_match.group(1) == 'True'
            else:
                print(f"Warning: Could not find DEBUG setting in {server_config_path}, using default {settings['server_debug']}.")

    except FileNotFoundError:
        # Handle case where server config file doesn't exist.
        print(f"Warning: {server_config_path} not found. Using default settings for WSS.")
    except Exception as e:
        # Handle other potential errors during file reading or regex parsing.
        print(f"Warning: Error reading {server_config_path}: {e}. Using default settings for WSS.")

    # --- Read Client Config (client/js/config.js) ---
    try:
        # Read the entire content of the client config file.
        with open(client_config_path, 'r', encoding='utf-8') as f:
            content = f.read()

            # Use regex to find the Client DEBUG setting (e.g., DEBUG: true, or DEBUG: false,).
            # \s* allows optional whitespace, (true|false) captures the boolean value.
            # ,? allows an optional trailing comma. re.IGNORECASE handles 'true' or 'True'.
            client_debug_match = re.search(r"^\s*DEBUG:\s*(true|false)\s*,?", content, re.MULTILINE | re.IGNORECASE)
            if client_debug_match:
                # Convert the captured JavaScript boolean string ('true'/'false') to an actual boolean value.
                settings['client_debug'] = client_debug_match.group(1).lower() == 'true'
            else:
                print(f"Warning: Could not find DEBUG setting in {client_config_path}, using default {settings['client_debug']}.")

    except FileNotFoundError:
        # Handle case where client config file doesn't exist.
        print(f"Warning: {client_config_path} not found. Using default setting for Client DEBUG.")
    except Exception as e:
        # Handle other potential errors during file reading or regex parsing.
        print(f"Warning: Error reading {client_config_path}: {e}. Using default setting for Client DEBUG.")

    print("Initial settings loaded.")
    return settings

def write_config(settings):
    """
    Writes the WSS settings (HOST, PORT, DEBUG) back to the server/config.py file.
    Reads the existing file, modifies relevant lines using regex, preserves other lines,
    and overwrites the file. Appends settings if they are not found. Creates the file if it doesn't exist.
    Uses repr() for string/boolean values to ensure proper Python syntax in the output file.
    Does NOT write HTTPS settings or Client DEBUG settings to this file.

    Args:
        settings (dict): Dictionary containing at least 'wss_host', 'wss_port', 'server_debug'.
                         Other keys (like https_host, https_port, client_debug) are ignored here.

    Returns:
        bool: True if writing was successful, False otherwise.
    """
    config_file_path = CONFIG_FILE_PATH
    try:
        lines = []
        try:
            # Read existing lines from the config file into a list.
            with open(config_file_path, 'r', encoding='utf-8') as f:
                lines = f.readlines()
        except FileNotFoundError:
            # If the file doesn't exist, proceed with an empty list of lines.
            pass

        new_lines = [] # List to hold the modified or preserved lines.
        # Flags to track if WSS settings were found and updated in the existing file.
        updated_flags = {'wss_host': False, 'wss_port': False, 'server_debug': False}

        # Define regex patterns and corresponding setting keys and format strings for WSS/Server Debug.
        # Use repr() when formatting string and boolean values to ensure correct Python syntax (e.g., quotes around strings).
        setting_patterns = {
            re.compile(r"^HOST\s*="): ('wss_host', "HOST = {value}\n"),
            re.compile(r"^PORT\s*="): ('wss_port', "PORT = {value}\n"),
            re.compile(r"^DEBUG\s*="): ('server_debug', "DEBUG = {value}\n"), # Matches DEBUG = True/False
        }

        # Iterate through the existing lines of the config file.
        for line in lines:
            line_updated = False
            # Check if the current line matches any of the setting patterns.
            for pattern, (key, format_str) in setting_patterns.items():
                # If a pattern matches the start of the line and this setting hasn't been updated yet...
                if pattern.match(line) and not updated_flags[key]:
                    # Format the new value. Use repr() for strings and booleans to get 'value' or True/False.
                    value_to_write = repr(settings[key]) if isinstance(settings[key], (str, bool)) else settings[key]
                    # Append the updated line (e.g., "HOST = '0.0.0.0'\n") to the new_lines list.
                    new_lines.append(format_str.format(value=value_to_write))
                    # Mark this setting as updated and break the inner loop (process next line).
                    updated_flags[key] = True
                    line_updated = True
                    break
            # If the line didn't match any setting pattern, append it unchanged.
            if not line_updated:
                new_lines.append(line)

        # Check for any settings that were not found in the existing file and need to be appended.
        appended_header = False
        for pattern, (key, format_str) in setting_patterns.items():
            if not updated_flags[key]:
                # Add a header comment if this is the first setting being appended.
                if not appended_header:
                    # Ensure there's a newline before the header if the file wasn't empty.
                    if new_lines and not new_lines[-1].endswith('\n'):
                        new_lines.append('\n')
                    new_lines.append("\n# --- Settings added/updated by helix_manager ---\n")
                    appended_header = True
                # Format the value using repr() for strings/booleans.
                value_to_write = repr(settings[key]) if isinstance(settings[key], (str, bool)) else settings[key]
                # Append the new setting line.
                new_lines.append(format_str.format(value=value_to_write))

        # Write the potentially modified lines back to the config file, overwriting it.
        with open(config_file_path, 'w', encoding='utf-8') as f:
            f.writelines(new_lines)
        return True # Indicate success
    except Exception as e:
        # Handle any errors during file reading or writing.
        print(f"Error writing Server configuration to {config_file_path}: {e}")
        return False # Indicate failure

def write_client_config(settings):
    """
    Writes the Client DEBUG setting back to the client/js/config.js file.
    Reads the existing file, modifies the relevant line using regex, preserves other lines,
    and overwrites the file. Appends the setting if it's not found. Creates the file if it doesn't exist.
    Uses lowercase 'true'/'false' for JavaScript boolean syntax.

    Args:
        settings (dict): Dictionary containing at least 'client_debug'. Other keys are ignored.

    Returns:
        bool: True if writing was successful, False otherwise.
    """
    config_file_path = CLIENT_CONFIG_FILE_PATH
    try:
        lines = []
        try:
            # Read existing lines from the client config file.
            with open(config_file_path, 'r', encoding='utf-8') as f:
                lines = f.readlines()
        except FileNotFoundError:
            # If the file doesn't exist, proceed with an empty list of lines.
            pass

        new_lines = [] # List to hold the modified or preserved lines.
        updated_flag = False # Flag to track if the DEBUG setting was found and updated.
        # Regex to find the DEBUG line, allowing for whitespace and an optional trailing comma. Case-insensitive.
        debug_pattern = re.compile(r"^\s*DEBUG:\s*(true|false)\s*,?", re.IGNORECASE)
        # Format string for writing/appending the DEBUG line, assuming standard indentation and comment.
        debug_format_str = "    DEBUG: {value}, // Default to false for production\n"

        # Iterate through the existing lines.
        for line in lines:
            match = debug_pattern.match(line)
            # If the line matches the DEBUG pattern and we haven't updated it yet...
            if match and not updated_flag:
                # Format the new value (lowercase 'true' or 'false' for JavaScript).
                value_to_write = str(settings['client_debug']).lower()
                # Attempt to preserve original indentation and comment structure.
                leading_whitespace = line[:match.start(1) - len("DEBUG: ")] # Capture leading space before 'DEBUG:'.
                trailing_comment = ""
                comment_match = re.search(r"//.*$", line) # Find any trailing comment on the line.
                if comment_match:
                    trailing_comment = comment_match.group(0)
                # Construct the new line content (e.g., "DEBUG: true,").
                new_line_content = f"DEBUG: {value_to_write}," # Assume comma was present.
                # Reconstruct the full line, padding the content to roughly match original length, and append comment.
                new_line = f"{leading_whitespace}{new_line_content:<{len(match.group(0))}} {trailing_comment}\n".rstrip() + "\n"
                # Fallback format if the reconstruction logic fails (e.g., unusual original formatting).
                if not new_line.strip().startswith("DEBUG:"):
                     new_line = debug_format_str.format(value=value_to_write)

                new_lines.append(new_line) # Add the updated line.
                updated_flag = True # Mark as updated.
            else:
                # If the line doesn't match or DEBUG was already updated, append the line unchanged.
                new_lines.append(line)

        # If the DEBUG line was not found in the existing file, append it.
        if not updated_flag:
            # Ensure there's a newline before appending if the file wasn't empty.
            if new_lines and not new_lines[-1].endswith('\n'):
                new_lines.append('\n')
            # Format the value (lowercase 'true' or 'false').
            value_to_write = str(settings['client_debug']).lower()
            # Append the new setting line using the standard format string.
            new_lines.append(debug_format_str.format(value=value_to_write))

        # Write the potentially modified lines back to the client config file, overwriting it.
        with open(config_file_path, 'w', encoding='utf-8') as f:
            f.writelines(new_lines)
        return True # Indicate success
    except Exception as e:
        # Handle any errors during file reading or writing.
        print(f"Error writing Client configuration to {config_file_path}: {e}")
        return False # Indicate failure


def config_menu(settings):
    """
    Displays the main configuration menu for HeliX. Allows modification of WSS, HTTPS,
    and Debug settings held in the 'settings' dictionary.
    WSS settings (HOST, PORT, DEBUG) and Client DEBUG setting are saved persistently
    to their respective config files when choosing to start the servers.

    Args:
        settings (dict): The current configuration values dictionary.

    Returns:
        bool: True if the user chose to start the servers, False if the user chose to exit.
    """
    while True:
        print("\n--- HeliX Configuration & Management ---")
        print(f"1. WSS Host:         {settings['wss_host']}")
        print(f"2. WSS Port:         {settings['wss_port']}")
        print(f"3. HTTPS Host:       {settings['https_host']}")
        print(f"4. HTTPS Port:       {settings['https_port']}")
        # Display Debug Modes status clearly.
        server_debug_status = "ENABLED" if settings['server_debug'] else "DISABLED"
        client_debug_status = "ENABLED" if settings['client_debug'] else "DISABLED"
        print(f"5. Server Debug Log: {server_debug_status}")
        print(f"6. Client Debug Log: {client_debug_status}")
        print("------------------------------------")
        print("7. Manage TLS Certificates (Check/Generate/Install CA)")
        print("8. Start HTTPS/WSS Servers")
        print("9. Exit")
        print("------------------------------------")
        choice = input("Enter choice: ").strip()

        if choice == '1':
            # Modify WSS Host
            new_val = input(f"Enter new WSS Host [{settings['wss_host']}]: ").strip()
            if new_val: settings['wss_host'] = new_val
        elif choice == '2':
            # Modify WSS Port
            new_val = input(f"Enter new WSS Port [{settings['wss_port']}]: ").strip()
            if new_val:
                try:
                    port_int = int(new_val)
                    # Validate port range (1-65535).
                    if not (0 < port_int < 65536):
                        print("Invalid port number (must be between 1 and 65535).")
                    else:
                        settings['wss_port'] = port_int
                except ValueError:
                    print("Invalid port. Please enter a number.")
        elif choice == '3':
            # Modify HTTPS Host (for this session only)
            new_val = input(f"Enter new HTTPS Host [{settings['https_host']}]: ").strip()
            if new_val: settings['https_host'] = new_val
        elif choice == '4':
            # Modify HTTPS Port (for this session only)
            new_val = input(f"Enter new HTTPS Port [{settings['https_port']}]: ").strip()
            if new_val:
                try:
                    port_int = int(new_val)
                    # Validate port range (1-65535).
                    if not (0 < port_int < 65536):
                        print("Invalid port number (must be between 1 and 65535).")
                    else:
                        settings['https_port'] = port_int
                except ValueError:
                    print("Invalid port. Please enter a number.")
        elif choice == '5':
            # Toggle Server Debug Mode
            settings['server_debug'] = not settings['server_debug']
            print(f"Server Debug Mode {'ENABLED' if settings['server_debug'] else 'DISABLED'}.")
        elif choice == '6':
            # Toggle Client Debug Mode
            settings['client_debug'] = not settings['client_debug']
            print(f"Client Debug Mode {'ENABLED' if settings['client_debug'] else 'DISABLED'}.")
        elif choice == '7': # Manage Certificates
            # Call the certificate generation/management function.
            if generate_certificates():
                print("Certificate process completed successfully.")
            else:
                print("Certificate process failed or aborted.")
            input("Press Enter to return...") # Pause before showing menu again.
            continue # Go back to the start of the menu loop.
        elif choice == '8': # Start Servers
            # Check if required certificate files exist before attempting to start.
            if not (os.path.exists(CERT_FILE) and os.path.exists(KEY_FILE)):
                print("\nError: Certificate files (cert.pem, key.pem) missing in 'certs/' directory.")
                print("Please use option 7 to generate certificates first.")
                input("Press Enter to return...")
                continue # Go back to the menu.
            # Attempt to write the persistent configurations (WSS Host/Port/Debug, Client Debug).
            print("Saving configuration...")
            server_saved = write_config(settings) # Writes WSS Host/Port, Server Debug
            client_saved = write_client_config(settings) # Writes Client Debug
            if server_saved and client_saved:
                # If both configurations saved successfully, signal to start servers.
                return True
            else:
                # If saving failed, report error and return to menu.
                print("Error: Failed to save one or more configuration files.")
                input("Press Enter to return...")
            continue # Go back to the menu.
        elif choice == '9': # Exit
            # Signal to exit the manager script without starting servers.
            return False
        else:
            # Handle invalid menu choices.
            print("Invalid choice. Please try again.")

# --- HTTPS Server Implementation ---
class QuietHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):
    """
    Custom HTTP request handler that logs messages to a dedicated file logger
    instead of printing to stderr, providing a cleaner console output.
    Inherits from SimpleHTTPRequestHandler to serve files.
    """
    def __init__(self, *args, directory=None, **kwargs):
        """
        Initializes the handler, ensuring the 'directory' argument is correctly
        passed to the parent class constructor. Uses functools.partial in the
        server setup to provide the directory.
        """
        # Ensure directory is set correctly before calling super().__init__
        if directory is None:
            directory = os.getcwd() # Default to current working directory if not provided
        # Call the parent class constructor with the specified directory.
        super().__init__(*args, directory=directory, **kwargs)

    def log_message(self, format, *args):
        """Overrides the default log_message to use the dedicated https_logger."""
        https_logger.info("%s - %s" % (self.address_string(), format % args))

    def log_error(self, format, *args):
        """Overrides the default log_error to use the dedicated https_logger."""
        https_logger.error("%s - %s" % (self.address_string(), format % args))

class ThreadingHTTPServer(ThreadingMixIn, http.server.HTTPServer):
    """
    An HTTPServer that uses threads to handle incoming requests concurrently.
    Inherits from ThreadingMixIn to add threading capabilities.
    """
    allow_reuse_address = True # Allow reusing the address (helpful for quick restarts)

def _start_https_server_thread(host, port, client_dir):
    """
    Internal helper function to configure and start the HTTPS server in a separate thread.
    Sets up SSL context using the generated certificates.

    Args:
        host (str): The host address for the HTTPS server to bind to.
        port (int): The port number for the HTTPS server to bind to.
        client_dir (str): The directory containing the client files to be served.

    Returns:
        threading.Thread or None: The thread object running the HTTPS server, or None if startup fails.
    """
    global https_server, https_thread # Allow modification of global variables
    print("\nStarting HTTPS server thread...")
    try:
        # Use functools.partial to create a handler factory that includes the target directory.
        # This allows passing the 'directory' argument to QuietHTTPRequestHandler when it's instantiated.
        Handler = partial(QuietHTTPRequestHandler, directory=client_dir)

        # Create the threaded HTTPS server instance.
        https_server = ThreadingHTTPServer((host, port), Handler)

        # Set up the SSL context for secure connections (HTTPS).
        print(f"[HTTPS Setup] Setting up SSL context...")
        context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER) # Use recommended TLS protocol.
        # Load the certificate and private key files.
        context.load_cert_chain(certfile=CERT_FILE, keyfile=KEY_FILE)
        # Wrap the server's socket with the SSL context.
        https_server.socket = context.wrap_socket(https_server.socket, server_side=True)
        print(f"[HTTPS Setup] SSL context loaded and socket wrapped.")

        # Create a new thread targeting the internal loop function (_run_https_server_loop).
        # Pass the server instance to the loop function.
        # daemon=True allows the main program to exit even if this thread is running.
        https_thread = threading.Thread(target=_run_https_server_loop, args=(https_server,), daemon=True)
        # Start the HTTPS server thread.
        https_thread.start()
        print(f"[HTTPS Thread] Serving HTTPS on {host}:{port} from {client_dir}")
        https_logger.info(f"HTTPS Server starting on {host}:{port}, serving {client_dir}")
        # Provide access URLs for convenience.
        print(f"[HTTPS Thread] Access client at: https://localhost:{port} or https://127.0.0.1:{port}")
        return https_thread # Return the thread object on success.
    except Exception as e:
        # Handle errors during server creation, SSL setup, or thread starting.
        print(f"\n[HTTPS Setup] ERROR starting HTTPS server: {e}")
        https_logger.exception("Error during HTTPS setup") # Log exception details to file.
        https_server = None # Ensure server reference is cleared on failure.
        return None # Return None on failure.

def _run_https_server_loop(server_instance):
    """
    Target function for the HTTPS server thread. Runs the server's main loop.
    Includes error handling and cleanup for the server instance.

    Args:
        server_instance: The http.server.HTTPServer instance to run.
    """
    global https_server # Allow modification of the global server reference
    try:
        # Call the server's serve_forever() method, which blocks until shutdown() is called.
        server_instance.serve_forever()
    except Exception as e:
        # Log unexpected errors that might occur within the serve_forever loop.
        https_logger.exception("Unexpected error in HTTPS serve_forever loop")
    finally:
        # Cleanup: Ensure the server socket is closed and the global reference is cleared.
        if server_instance:
            try:
                server_instance.server_close() # Close the server socket.
            except Exception:
                pass # Ignore errors during close, as the server might already be down.
        print("[HTTPS Thread] Server loop stopped.")
        https_logger.info("HTTPS Server loop stopped.")
        https_server = None # Clear the global reference to indicate the server is stopped.

# --- WSS Server Logging ---
def log_wss_output(process):
    """
    Target function for the WSS logging thread. Reads stdout from the WSS server
    subprocess line by line and prints it to the console, prefixed with '[WSS]'.
    Stops reading when the stop_event is set or the process terminates.

    Args:
        process: The subprocess.Popen object representing the running WSS server.
    """
    print("[WSS Log Thread] Started.")
    try:
        # Read stdout line by line from the WSS process.
        # iter(process.stdout.readline, '') creates an iterator that calls readline()
        # until it returns an empty string (indicating EOF or process termination).
        for line in iter(process.stdout.readline, ''):
            # Check if the main thread has signaled for shutdown.
            if stop_event.is_set():
                break
            # Print the line received from the WSS server, stripping whitespace and flushing output.
            print(f"[WSS] {line.strip()}", flush=True)
        # Check if the loop ended because the process terminated unexpectedly (not due to stop_event).
        if not stop_event.is_set() and process.poll() is not None:
             print("[WSS Log Thread] WSS process stdout EOF or process terminated.", flush=True)
    except Exception as e:
        # Log errors during reading, but only if shutdown wasn't requested via stop_event.
        if not stop_event.is_set():
            print(f"[WSS Log Thread] Error reading WSS output: {e}", flush=True)
    finally:
        # Log when the thread is exiting.
        print("[WSS Log Thread] Exiting.", flush=True)

def _start_wss_server_process():
    """
    Internal helper function to start the WSS server (server/main.py) as a subprocess.
    Captures its stdout/stderr and starts a separate thread (log_wss_output) to display the logs.

    Returns:
        subprocess.Popen or None: The Popen object for the WSS server process, or None if startup fails.
    """
    global wss_process, wss_log_thread # Allow modification of global variables
    print("Starting WSS server subprocess...")
    # Construct the path to the WSS server's main script.
    wss_script_path = os.path.join(SCRIPT_DIR, 'server', 'main.py')
    try:
        # Start the server/main.py script using the same Python interpreter that's running this manager.
        wss_process = subprocess.Popen(
            [sys.executable, wss_script_path],
            stdout=subprocess.PIPE,    # Capture standard output.
            stderr=subprocess.STDOUT,  # Redirect standard error to standard output, so both are captured by stdout.
            text=True,                 # Decode stdout/stderr as text using default encoding.
            encoding='utf-8',          # Specify UTF-8 encoding explicitly for consistency.
            bufsize=1,                 # Use line buffering for stdout/stderr (process output line by line).
            cwd=SCRIPT_DIR             # Set the working directory for the subprocess to the manager's directory.
        )
        print(f"WSS server process started (PID: {wss_process.pid}). Output will follow:")
        # Start a separate thread to read and print the WSS server's output in real-time.
        # Pass the Popen object to the logging function.
        # daemon=True allows the main program to exit even if this thread is running.
        wss_log_thread = threading.Thread(target=log_wss_output, args=(wss_process,), daemon=True)
        wss_log_thread.start()
        return wss_process # Return the Popen object on success.
    except Exception as e:
        # Handle errors during subprocess creation.
        print(f"Error starting WSS server process: {e}")
        wss_process = None # Ensure process reference is cleared on failure.
        return None # Return None on failure.

# --- Server Startup and Management ---
def start_servers(settings):
    """
    Starts the HTTPS server thread and the WSS server subprocess using the provided settings.
    Enters a monitoring loop to keep the manager script alive while servers run.
    Handles graceful shutdown on Ctrl+C or unexpected server termination.

    Args:
        settings (dict): The current configuration settings dictionary (includes WSS and HTTPS host/port).
                         Note: The WSS server process reads its config directly from server/config.py.
    """
    global wss_process, https_thread, wss_log_thread, https_server, stop_event # Allow access to global state

    # Reset global state variables before starting servers.
    wss_process, https_thread, wss_log_thread, https_server = None, None, None, None
    stop_event.clear() # Ensure the stop event is not set initially.

    servers_started_ok = False
    print("Starting local servers...")
    # Start the HTTPS server thread first.
    https_thread = _start_https_server_thread(
        settings['https_host'], settings['https_port'], HTTPS_CLIENT_DIR
    )
    # Short pause to allow the HTTPS server time to bind to the port or fail.
    time.sleep(1.0)

    # Check if the HTTPS server thread started successfully and is alive.
    if https_thread and https_thread.is_alive():
        # If HTTPS is okay, start the WSS server process.
        # The WSS server reads its own configuration (HOST/PORT/DEBUG) from server/config.py.
        wss_process = _start_wss_server_process()
        if wss_process:
            servers_started_ok = True # Both servers seem to have started successfully.
        else:
            # WSS server failed to start.
            print("Failed to start WSS server process. Shutting down HTTPS server.")
    else:
        # HTTPS server failed to start.
        print("Failed to start HTTPS server thread.")

    # If any part of the startup failed, trigger immediate cleanup.
    if not servers_started_ok:
         stop_event.set() # Signal any potentially running threads (like WSS logger if WSS started briefly) to stop.
         # Call the shutdown logic directly.
         _shutdown_servers()
         print("Exiting due to server startup failure.")
         sys.exit(1) # Exit the manager script with an error code.

    # --- Manage Running Servers ---
    print("\nServers are running. Press Ctrl+C to stop.")
    try:
        # Main loop to monitor server status while running. Keeps the manager script alive.
        while not stop_event.is_set():
            # Check if the WSS process has terminated unexpectedly.
            # poll() returns the exit code if terminated, None otherwise.
            if wss_process and wss_process.poll() is not None:
                print(f"\nError: WSS server process terminated unexpectedly (Exit Code: {wss_process.returncode}).")
                stop_event.set() # Signal shutdown.
                break # Exit the monitoring loop.
            # Check if the HTTPS thread has terminated unexpectedly.
            if https_thread and not https_thread.is_alive():
                 # Differentiate between the thread dying after successful startup vs. failing during startup.
                 if https_server is not None: # https_server is only set after successful startup in _start_https_server_thread
                     print("\nError: HTTPS server thread terminated unexpectedly.")
                 else:
                     print("\nError: HTTPS server failed during startup.") # Should have been caught earlier, but check again.
                 stop_event.set() # Signal shutdown.
                 break # Exit the monitoring loop.
            # Pause briefly to avoid consuming excessive CPU in the loop.
            time.sleep(0.5)
    except KeyboardInterrupt:
        # Handle Ctrl+C gracefully.
        print("\nShutdown signal (Ctrl+C) received...")
        stop_event.set() # Signal threads and the loop to stop.
    except Exception as e:
        # Handle any other unexpected errors in the monitoring loop.
        print(f"\nUnexpected error in main wait loop: {e}")
        stop_event.set() # Signal shutdown.
    finally:
        # --- Graceful Shutdown Sequence ---
        # Ensure the shutdown logic runs regardless of how the loop exited (Ctrl+C, error, server crash).
        _shutdown_servers()

def _shutdown_servers():
    """
    Internal helper function to perform the graceful shutdown sequence for both servers and their threads.
    """
    global wss_process, https_thread, wss_log_thread, https_server # Allow access to global state

    print("Initiating server shutdown...")

    # 1. Shutdown HTTPS Server
    # Check if the server instance exists (it might be None if startup failed).
    if https_server:
        print("Shutting down HTTPS server...")
        https_server.shutdown() # Tell the server's serve_forever loop to stop.
    # Check if the thread exists and is still alive.
    if https_thread and https_thread.is_alive():
        print("Waiting for HTTPS thread...")
        https_thread.join(timeout=5) # Wait for the thread to finish (up to 5 seconds).
        # Check again if the thread terminated gracefully.
        if https_thread.is_alive():
            print("Warning: HTTPS thread did not exit gracefully.")
    https_thread = None # Clear the global thread reference.

    # 2. Shutdown WSS Process
    # Check if the process exists and is still running (poll() returns None if running).
    if wss_process and wss_process.poll() is None:
        print("Terminating WSS server process...")
        try:
            # Attempt graceful termination first (sends SIGTERM).
            wss_process.terminate()
            wss_process.wait(timeout=5) # Wait for the process to exit (up to 5 seconds).
            print("WSS server process terminated.")
        except subprocess.TimeoutExpired:
            # If terminate() doesn't work within the timeout, forcefully kill the process (sends SIGKILL).
            print("WSS process did not terminate gracefully, killing.")
            wss_process.kill()
            try:
                # Wait briefly after kill to allow OS cleanup.
                wss_process.wait(timeout=2)
            except Exception:
                pass # Ignore errors during wait after kill.
        except Exception as e:
            # Handle other potential errors during termination.
            print(f"Error terminating WSS process: {e}")
        finally:
            wss_process = None # Clear the global process reference.

    # 3. Shutdown WSS Logging Thread
    # Check if the thread exists and is alive. stop_event should have been set already.
    if wss_log_thread and wss_log_thread.is_alive():
        print("Waiting for WSS logging thread...")
        wss_log_thread.join(timeout=2) # Wait for the thread to finish (up to 2 seconds).
        # Check again if the thread terminated gracefully.
        if wss_log_thread.is_alive():
            print("Warning: WSS logging thread did not exit.")
    wss_log_thread = None # Clear the global thread reference.

    print("Shutdown complete.")


# --- Main Execution ---
def main():
    """
    Main function for the HeliX Manager script.
    Orchestrates the workflow: check dependencies, read configuration, display the menu,
    and if requested, start and manage the servers.
    """
    print("--- Starting HeliX Manager ---")
    # 1. Check if required Python packages are installed.
    check_dependencies()
    # 2. Read current configuration settings from files (or use defaults).
    current_settings = read_config()
    # 3. Display the configuration menu and get user choice (start servers or exit).
    should_start = config_menu(current_settings)

    # 4. If the user chose to start the servers...
    if should_start:
        # Start the servers using the potentially modified settings.
        # This function enters the monitoring loop and handles shutdown.
        start_servers(current_settings)
    else:
        # User chose to exit from the menu.
        print("Exiting HeliX Manager.")

# Standard Python idiom: Run the main() function only when the script is executed directly.
if __name__ == "__main__":
    main()
